import esri = __esri;

import { EsriBundle, InfoBundle, ArcGisServerUrl } from '../gapiTypes';
import BaseBase from '../BaseBase';
import defaultRenderers from './defaultRenderers.json';
import ArcGIS from 'terraformer-arcgis-parser';

/**
 * Maps GeoJSON geometry types to a set of default renders defined in GlobalStorage.DefaultRenders
 * @property featureTypeToRenderer {Object}
 * @private
 */
const featureTypeToRenderer = {
    Point: 'circlePoint',
    MultiPoint: 'circlePoint',
    LineString: 'solidLine',
    MultiLineString: 'solidLine',
    Polygon: 'outlinedPoly',
    MultiPolygon: 'outlinedPoly'
};

/**
 * Performs in place assignment of integer ids for a GeoJSON FeatureCollection.
 * If at least one feature has an existing id outside the geoJson properties section,
 * the original id value is copied in a newly created property ID_FILE of the properties object
 * and the existing id value is replaced by an autogenerated number.
 * Features without existing id from that same dataset will get a new properties ID_FILE
 * with an empty string as value.
 **************************************
 * If at least one feature has an existing OBJECTID inside the geoJson properties section,
 * the original OBJECTID value is copied in a newly created property OBJECTID_FILE of the properties object
 * and the existing OBJECTID value is replaced by an autogenerated number.
 * Features without existing OBJECTID from that same dataset will get a new properties OBJECTID_FILE
 * with an empty string as value.
 */
function assignIds(geoJson: any) {
    if (geoJson.type !== 'FeatureCollection') {
        throw new Error('GeoJSON is not in FeatureCollection format');
    }

    let emptyID: boolean = true;
    let emptyObjID: boolean = true;

    // create an 'id' property for every feature, doing autonumber.
    // 0 is not a valid object id
    geoJson.features.forEach((val: any, idx: number) => {
        Object.assign(val.properties, { ID_FILE: '', OBJECTID_FILE: '' });

        // to avoid double ID columns outside properties
        if ('id' in val && typeof val.id !== 'undefined') {
            val.properties.ID_FILE = val.id;
            emptyID = false;
        }

        // to avoid double OBJECTID columns. Useful for both geojson and CSV file.
        if ('OBJECTID' in val.properties) {
            val.properties.OBJECTID_FILE = val.properties.OBJECTID;
            delete val.properties.OBJECTID;
            emptyObjID = false;
        }

        val.id = idx + 1;
    });

    // remove ID_FILE if all empty
    if (emptyID) {
        geoJson.features.forEach(function (val) {
            delete val.properties.ID_FILE;
        });
    }

    // remove OBJECTID_FILE if all empty
    if (emptyObjID) {
        geoJson.features.forEach(function (val) {
            delete val.properties.OBJECTID_FILE;
        });
    }
}


/**
 * Extracts fields from the first feature in the feature collection, does no
 * guesswork on property types and calls everything a string.
 */
function extractFields(geoJson) {
    if (geoJson.features.length < 1) {
        throw new Error('Field extraction requires at least one feature');
    }

    if (geoJson.features[0].properties) {
        return Object.keys(geoJson.features[0].properties).map(function (prop) {
            return { name: prop, type: 'esriFieldTypeString' };
        });
    } else {
        return [];
    }
}

/**
 * Rename any fields with invalid names. Both parameters are modified in place.
 *
 * @function cleanUpFields
 * @param {Object} geoJson           layer data in geoJson format
 * @param {Object} layerDefinition   layer definition of feature layer not yet created
 */
function cleanUpFields(geoJson, layerDefinition) {
    const badField = name => {
        // basic for now. check for spaces.
        return name.indexOf(' ') > -1;
    };

    layerDefinition.fields.forEach(f => {
        if (badField(f.name)) {
            const oldField = f.name;
            let newField;
            let underscore = '_';
            let badNewName;

            // determine a new field name that is not bad and is unique, then update the field definition
            do {
                newField = oldField.replace(/ /g, underscore);
                badNewName = layerDefinition.fields.find(f2 => f2.name === newField);
                if (badNewName) {
                    // new field already exists. enhance it
                    underscore += '_';
                }
            } while (badNewName)

            f.alias = oldField;
            f.name = newField;

            // update the geoJson to reflect the field name change.
            geoJson.features.forEach(gf => {
                gf.properties[newField] = gf.properties[oldField];
                delete gf.properties[oldField];
            });
        }
    });

}

export default class FileUtils extends BaseBase {

    constructor (infoBundle: InfoBundle) {
        super(infoBundle);
    }

    geoJsonToEsriJson(geoJson: any, options: any): Promise<any> {

        let targetSR;
        let srcProj = 'EPSG:4326'; // 4326 is the default for GeoJSON with no projection defined
        let layerId;
        const layerDefinition: any = {
            objectIdField: 'OBJECTID',
            fields: [
                {
                    name: 'OBJECTID',
                    type: 'oid',
                }
            ]
        };

        // ensure our features have ids
        assignIds(geoJson);
        layerDefinition.drawingInfo =
            defaultRenderers[featureTypeToRenderer[geoJson.features[0].geometry.type]];

        // attempt to get spatial reference from geoJson
        if (geoJson.crs && geoJson.crs.type === 'name') {
            srcProj = geoJson.crs.properties.name;
        }

        // pluck treats from options parameter
        if (options) {
            if (options.sourceProjection) {
                srcProj = options.sourceProjection;
            }

            if (options.targetSR) {
                targetSR = options.targetSR;
            } else if (options.targetWkid) {
                // technically no longer supported, but we'll be nice and convert up
                console.warn('Suggest using option targetSR instead of targetWkid, as unofficial support for targetWkid may end at any time');
                targetSR = {
                    wkid: options.targetWkid
                };
            } else {
                throw new Error('makeGeoJsonLayer - missing opts.targetSR arguement');
            }

            if (options.layerId) {
                layerId = options.layerId;
            } else {
                layerId = this.gapi.utils.shared.generateUUID();
            }

            // TODO add support for renderer option, or drop the option

        } else {
            throw new Error('makeGeoJsonLayer - missing opts arguement');
        }

        if (layerDefinition.fields.length === 1) {
            // caller has not supplied custom field list. so take them all.
            layerDefinition.fields = layerDefinition.fields.concat(extractFields(geoJson));
        }

        // clean the fields. in particular, CSV files can be loaded with spaces in
        // the field names
        cleanUpFields(geoJson, layerDefinition);

        const destProj = this.gapi.utils.proj.normalizeProj(targetSR);

        // look up projection definitions if they don't already exist and we have enough info
        const srcLookup = this.gapi.utils.proj.checkProj(srcProj, opts.epsgLookup);

        // note we need to use the SR object, not the normalized string, as checkProj cant handle a raw WKT
        //      and this function won't have a raw EPSG code / proj4 string coming from param targetSR
        const destLookup =  this.gapi.utils.proj.checkProj(targetSR, opts.epsgLookup);

        // change latitude and longitude fields from esriFieldTypeString -> esriFieldTypeDouble if they exist
        if (options) {
            if (options.latfield) {
                const latField = layerDefinition.fields.find(field => field.name === options.latfield);
                if (latField) {
                    latField.type = 'esriFieldTypeDouble';
                }
            }
            if (options.lonfield) {
                const longField = layerDefinition.fields.find(field => field.name === options.lonfield);
                if (longField) {
                    longField.type = 'esriFieldTypeDouble';
                }
            }
        }

        // make the layer
        // TODO the layer gets made in layer constructor now. odds are we just need to return a nicely formatted object with all the treats
        const buildLayer = () => {
            return new Promise(resolve => {
                // project data and convert to esri json format

                const fancySR = new this.esriBundle.SpatialReference(targetSR);

                this.gapi.utils.proj.projectGeoJson(geoJson, destProj, srcProj);

                // terraformer has no support for non-wkid layers. can also do funny things if source is 102100.
                // use 8888 as placehold then adjust below
                const esriJson = ArcGIS.convert(geoJson, { sr: 8888 });
                const geometryType = layerDefinition.drawingInfo.geometryType;

                // set proper SR on the geometeries
                esriJson.forEach(gr => {
                    gr.geometry.spatialReference = fancySR;
                });

                const fs = {
                    features: esriJson,
                    geometryType
                };

                const layer = new esriBundle.FeatureLayer(
                    {
                        layerDefinition: layerDefinition,
                        featureSet: fs
                    }, {
                        id: layerId
                    });

                // ＼(｀O´)／ manually setting SR because it will come out as 4326
                layer.spatialReference = fancySR;

                if (opts.colour) {
                    layer.renderer.symbol.color = new esriBundle.Color(opts.colour);
                }

                // initializing layer using JSON does not set this property. do it manually.
                layer.geometryType = geometryType;
                resolve(layer);
            });
        };

        // call promises in order
        return srcLookup.lookupPromise
            .then(() => destLookup.lookupPromise)
            .then(() => buildLayer());
    }

}